// --------------------------------------------------------------------------
//
// ARGENT: Basic Actors & Stuff
//
// --------------------------------------------------------------------------

class ArgTrail : Actor
{
	Default
	{
		-RANDOMIZE
		+NOBLOCKMONST
		+NOTELEPORT
		+FORCEXYBILLBOARD
		+NOBLOCKMAP
		+NOGRAVITY
		+THRUACTORS
	}
}

class ArgTrailNoPhysics : Actor
{
	Default
	{
		+NOINTERACTION
	}
}

class ArgDrop : ArgTrail
{
	Default
	{
		Projectile;
		Damage 0;
		Speed 0;

		-NOGRAVITY
	}
}

class ArgPuff : Actor
{
	Default
	{
		+NOGRAVITY
		+PUFFGETSOWNER
		+PUFFONACTORS
	}
}

class ArgToken : Inventory
{
	Default
	{
		+INVENTORY.UNDROPPABLE
	}
}

class ArgNothing : Actor
{
	Default
	{
		+NOINTERACTION
	}
	States
	{
	Spawn:
		TNT1 A 0;
		Stop;
	}
}

class ArgRocketBase : FastProjectile // so Cyber & Player rockets can share some stuff.
{
	Default {
		Radius 11;
		Height 8;
		Speed 20;
		Damage 20;
		Scale 0.75;
		DeathSound "weapons/rocket/explode";
		MissileType "ArgRocketTrailSpawner";
		MissileHeight 13;
		Decal "Scorch";
		Obituary "$ARG_OB_ROCKET";
	
		+EXTREMEDEATH
	}
	States
	{
	Spawn:
		MISL A 1 Bright;
		Loop;
	Death:
		REXP A 4 Bright {
			A_SetScale(1.0);
			A_Explode(200, 128, 1);
		}
	Boom:
		REXP B 3 Bright;
		REXP C 3 Bright A_SetTranslucent(0.7);
		REXP D 2 Bright A_SetTranslucent(0.6);
		REXP E 2 Bright A_SetTranslucent(0.5);
		REXP F 2 Bright A_SetTranslucent(0.4);
		Stop;
	}
}

class ArgRocketTrailSpawner : ArgTrail
{
	Default {
		RenderStyle "None";
	}
	States
	{
	Spawn:
		TNT1 A 1 NoDelay A_SpawnItemEx("ArgRocketTrail", 0, 0, 0, 0, frandom[ArgRocketTrailSpawner](-0.33, 0.33), frandom[ArgRocketTrailSpawner](-0.33, 0.33));
		Stop;
	}
}

class ArgRocketTrail : ArgTrail
{
	Default {
		RenderStyle "Add";
		Alpha 0.5;
		Scale 0.25;
	}
	States
	{
	Spawn:
		RTRL HHABCDEFG 1 Bright;
		Stop;
	}
}

/*
 * Basic "counter" struct. Represents the concept of a number with a capped
 * maximum; also includes a special "end" value that can be set higher than
 * the max to allow for "over-max" -- this is often used in argent to control
 * a looping sound after the charge has already hit its theoretical maximum.
 *
 * [XA] I may deprecate and remove this, since it's pretty over-engineered.
 */
struct ArgCounter
{
	int val;
	int min;
	int max;
	int over;
	bool locked;
	
	ArgCounter init(int v = 0, int m = 1, int o = 1)
	{
		self.val = 0;
		self.min = v;
		self.max = m;
		self.over = self.clamp(m, o, o); // cow level confirmed
		return self;
	}
	int get(bool over = false)
	{
		return over
			? self.clamp(self.min, self.val, self.over)
			: self.clamp(self.min, self.val, self.max)
		;
	}
	ArgCounter set(int v)
	{
		self.val = self.clamp(self.min, v, self.over);
		return self;
	}
	ArgCounter toMin()
	{
		self.val = min;
		return self;
	}
	ArgCounter toMax()
	{
		self.val = self.max;
		return self;
	}
	ArgCounter toOver()
	{
		self.val = self.over;
		return self;
	}
	ArgCounter inc(int amount = 1)
	{
		self.set(self.val + amount);
		return self;
	}
	ArgCounter dec(int amount = 1)
	{
		if(!self.locked) {
			self.set(self.val - amount);
		}
		return self;
	}
	ArgCounter lock()
	{
		self.locked = true;
		return self;
	}
	ArgCounter unlock()
	{
		self.locked = false;
		return self;
	}
	bool isMin()
	{
		return self.val == self.min;
	}
	bool isMax()
	{
		return self.val >= self.max;
	}
	bool isOver()
	{
		return self.val == self.over;
	}
	int clamp(int l, int m, int h)
	{
		if(m < l) {
			return l;
		} else if (h < m) {
			return h;
		}
		return m;
	}
}

/*
 * Enums for Common stuff
 */
enum Arg_TossGibsFlags
{
	ARG_TG_FALL   = 1, // Call A_NoBlocking after tossing gibs.
	ARG_TG_SOUND  = 2, // Play gibbing sound effect after tossing gibs.
	ARG_TG_SCREAM = 4, // Play scream sound effect after tossing gibs.
};

enum Arg_WeaponState // technically a copypasta of some internal non-exposed enums
{
	ARG_WF_WEAPONREADY    =    1,
	ARG_WF_WEAPONBOBBING  =    2,
	ARG_WF_WEAPONREADYALT =    4,
	ARG_WF_WEAPONSWITCHOK =    8,
	ARG_WF_DISABLESWITCH  =   16,
	ARG_WF_WEAPONRELOADOK =   32,
	ARG_WF_WEAPONZOOMOK   =   64,
	ARG_WF_REFIRESWITCHOK =  128,
	ARG_WF_USER1OK        =  256,
	ARG_WF_USER2OK        =  512,
	ARG_WF_USER3OK        = 1024,
	ARG_WF_USER4OK        = 2048,
};

/*
 * Singleton class for global variables; also houses common staticfunctions .
 */
class ArgCommon : Thinker
{
	Array<ArgMerch> merch;

	/*
	 * Init global variables.
	 */
	ArgCommon Init()
	{
		// set up the merch array; this lists all the stuff "for sale" in the
		// mod kit menu that aren't mods -- e.g. backpack, equipment, etc.
		merch.push(ArgMerch.Create('Backpack'            , '$ARG_TAG_BACKPACK', '$ARG_MERCH_DESC_BACKPACK', '$ARG_MERCH_ICON_BACKPACK', '$ARG_MERCH_PIC_BACKPACK' ));
		merch.push(ArgMerch.Create('ArgEquipmentGrenade' , '$ARG_TAG_GRENADE' , '$ARG_MERCH_DESC_GRENADE' , '$ARG_MERCH_ICON_GRENADE' , '$ARG_MERCH_PIC_GRENADE'  ));
		merch.push(ArgMerch.Create('ArgEquipmentHologram', '$ARG_TAG_HOLOGRAM', '$ARG_MERCH_DESC_HOLOGRAM', '$ARG_MERCH_ICON_HOLOGRAM', '$ARG_MERCH_PIC_HOLOGRAM' ));
		merch.push(ArgMerch.Create('ArgEquipmentSiphon'  , '$ARG_TAG_SIPHON'  , '$ARG_MERCH_DESC_SIPHON'  , '$ARG_MERCH_ICON_SIPHON'  , '$ARG_MERCH_PIC_SIPHON'   ));
		
		// do some housekeeping n' return
		ChangeStatNum(STAT_STATIC);
		return self;
	}

	/*
	 * Get ArgCommon singleton to access global variables.
	 */
	static ArgCommon Get()
	{
		ThinkerIterator it = ThinkerIterator.Create("ArgCommon", STAT_STATIC);
		let p = ArgCommon(it.Next());
		if (p == null)
		{
			p = new("ArgCommon").Init();
		}
		return p;
	}

	/*
	 * Convenience function; jumps to XDeath if the Always Gib cvar is set.
	 */
	static state GibCheck(Actor this)
	{
		return this.GetCvar("arg_alwaysgib") ? this.ResolveState("XDeath") : this.ResolveState(null);
	}

	/*
	 * Gib tossing action. Throws up to 'count' actors of 'type' from the calling
	 * actor using the specified height/speed values (varied a bit for random's sake).
	 * Includes a couple of convenience flags to chain additional actions.
	 */
	static void TossGibs(Actor this, class<Actor> type, int count, int flags, double spawndist, double spawnheight, double xspeed, double yspeed)
	{
		// Randomly subtract 1 or 2 from the count to vary the number of gibs a bit.
		count = count - random(0, 2);
		
		for(int i = 0; i < count; i++) {
			this.A_SpawnItemEx(type
			,	frandom(-spawndist, spawndist)
			,	frandom(-spawndist, spawndist)
			,	spawnheight + frandom(-2, 2)
			,	xspeed * frandom(-1.0, 1.0)
			,	xspeed * frandom(-1.0, 1.0)
			,	yspeed * frandom( 0.5, 1.5)
			,	0
			,	SXF_USEBLOODCOLOR
			,	0
			);
		}
		
		// Do optional flaggy stuff.
		if(flags & ARG_TG_FALL) {
			this.A_NoBlocking();
		}
		if(flags & ARG_TG_SOUND) {
			this.A_PlaySound("effects/splat", CHAN_AUTO);
			this.A_PlaySound("effects/gibs", CHAN_AUTO);
		}
		if(flags & ARG_TG_SCREAM) {
			this.A_Scream();
		}
	}
}
