// --------------------------------------------------------------------------
//
// ARGENT: Base Weapon Definitions
//
// --------------------------------------------------------------------------

/*
 * Base weapon class. Contains common functions and properties for all of
 * ARGENT's weapons, naturally. Non-moddable weapons (e.g. pistol, SSG, BFG)
 * inherit directly from this class.
 */
class ArgWeapon : DoomWeapon
{
	bool altSound;
	
	Default
	{
		Inventory.PickupSound "items/weapon";
		Weapon.UpSound "weapons/swap";
		Weapon.BobStyle "InverseSmooth";
		Weapon.BobSpeed  2.00;
		Weapon.BobRangeX 0.75;
		Weapon.BobRangeY 0.50;
		Weapon.SelectionOrder 9999999;
		Scale 0.75;
	
		+WEAPON.NOALERT
	}
	States
	{
	Spawn:
		TNT1 A 1;
		Stop;
	Ready:
		TNT1 A 1 A_WeaponReady;
		Loop;
	Select:
		"####" "#" 0;
	SelectLoop:
		"####" "#" 1 Arg_A_Raise();
		Loop;
	Deselect:
	DeselectLoop:
		"####" "#" 1 Arg_A_Lower();
		Loop;
	Fire:
		TNT1 A 1;
		Goto Ready;
	DeadLowered:
		TNT1 A 1;
		Loop;
	}
	
	/*
	 * Double-speed A_Raise/A_Lower, for convenience.
	 */
	action void Arg_A_Lower() {
		A_Lower();
		A_Lower();
	}
	action void Arg_A_Raise() {
		A_Raise();
		A_Raise();
	}
	
	/*
	 * A_GunFlash extension, wrapping a whole bunch of cool
	 * common stuff, like A_WeaponReady, A_PlaySound, and the like.
	 */
	enum Arg_A_GunFlashFlags {
		ARG_GF_NOALERT  = 1, // Don't call A_AlertMonsters.
		ARG_GF_ALTSOUND = 2, // Alternate firing sound between channels 5 and 6
		ARG_GF_BOB      = 4, // Continue bobbing when firing (i.e. call A_WeaponReady)
	}
	action void Arg_A_GunFlash(statelabel flashstate = null, sound flashsound = "", int flags = 0, double recoil = 0) {
		A_GunFlash(flashstate);
		
		if(!(flags & ARG_GF_NOALERT)) {
			A_AlertMonsters();
		}
		if(flashsound != "") {
			if(flags & ARG_GF_ALTSOUND) {
				A_PlaySound(flashsound, invoker.altSound ? CHAN_6 : CHAN_5);
				invoker.altSound = !invoker.altSound;
			} else {
				A_PlaySound(flashsound, CHAN_5);
			}
		}
		if(flags & ARG_GF_BOB) {
			A_WeaponReady(WRF_NOFIRE | WRF_NOFIRE);
		}
		if(recoil > 0) {
			A_Recoil(recoil);
		}
	}
	
	/*
	 * Convenient ammo-taker function. Since ARGENT weapons only use a single
	 * ammo type, just subtract a bit from AmmoType1. Easy-peasy.
	 */
	action void Arg_A_TakeAmmo(int amount = 1)
	{
		A_TakeInventory(invoker.AmmoType1, amount, TIF_NOTAKEINFINITE);
	}
	
	/*
	 * Manually check if the player has ammo, to circumvent AMMO_OPTIONAL.
	 */
	action bool Arg_A_CheckAmmo(int amount = 0)
	{
		if(amount == 0) {
			amount = invoker.AmmoUse1;
		}
		if(CountInv(invoker.AmmoType1) < amount) {
			A_SelectWeapon("None", SWF_SELECTPRIORITY);
			return false;
		} else {
			return true;
		}
	}
	
	/*
	 * A certain function that would've been nice to have built-in for ages. ;)
	 */
	action state Arg_A_JumpIfNoAmmo(statelabel state = 'Ready', int amount = 1)
	{
		return (CountInv(invoker.AmmoType1) < amount) ? ResolveState(state) : ResolveState(null);
	}
	
	/*
	 * The inverse of the above, for completeness' sake.
	 */
	action state Arg_A_JumpIfAmmo(statelabel state = 'Ready', int amount = 1)
	{
		return (CountInv(invoker.AmmoType1) >= amount) ? ResolveState(state) : ResolveState(null);
	}
	
	/*
	 * Synth-fire convenience functions. Comes in both
	 * check and jump variants. Note that the 'checks' need to be labeled
	 * with "action" even though they kinda aren't; funky compat stuff.
	 */
	action bool Arg_SynthFire   (bool checkAmmo = false) {
		return (GetPlayerInput(INPUT_BUTTONS) & BT_ATTACK   ) && (!checkAmmo || CountInv(invoker.AmmoType1) > 0);
	}
	action bool Arg_SynthAltFire(bool checkAmmo = false) {
		return (GetPlayerInput(INPUT_BUTTONS) & BT_ALTATTACK) && (!checkAmmo || CountInv(invoker.AmmoType1) > 0);
	}
	action state Arg_A_SynthFire(statelabel label) {
		return Arg_SynthFire() ? ResolveState(label) : ResolveState(null);
	}
	action state Arg_A_SynthAltFire(statelabel label) {
		return Arg_SynthAltFire() ? ResolveState(label) : ResolveState(null);
	}
	
	/*
	 * Slightly more generic versions of the above.
	 */
	action bool Arg_Buttons(int button) {
		return (GetPlayerInput(INPUT_BUTTONS) & button);
	}
	action bool Arg_OldButtons(int button) {
		return (GetPlayerInput(INPUT_OLDBUTTONS) & button);
	}
	
	/*
	 * Weapon Offset function alias. This does two things mainly:
	 * - adjusts 'y' by 32 so that (0,0) is actually the origin, and
	 * - adds a convenient parameter for random jitter, as that's common.
	 */
	action void Arg_A_WeaponOffset(double x, double y, double j = 0, double k = 0) {
		k = (k == 0) ? j : k; // means you can't do x-only jitter, but meh
		A_WeaponOffset(x + frandom(-j, j), 32.0 + y + frandom(-k, k), WOF_INTERPOLATE);
	}
}

/*
 * Base class for moddable weapons, containing all the cool common code
 * for swapping and equipping mods (as well as handling various facets
 * of mod fires like the usual "altfire to charge, fire-to-fire" system).
 * Bit complex, but most of the guts are nicely laid out here now.
 */
class ArgModWeapon : ArgWeapon
{
	/*
	 * Mod definition & control.
	 */
	int modSelected;
	ArgMod[3] mod; // mod[0] is used as a placeholder for "no mod selected."

	int    init_mod1_ammoUse; // custom property drivers
	int    init_mod1_cooldown;
	int    init_mod1_cooldown_over;
	int    init_mod1_charge;
	int    init_mod1_charge_over;
	string init_mod1_tag;
	string init_mod1_description;
	string init_mod1_icon;
	string init_mod1_pic;

	int    init_mod2_ammoUse;
	int    init_mod2_cooldown;
	int    init_mod2_cooldown_over;
	int    init_mod2_charge;
	int    init_mod2_charge_over;
	string init_mod2_tag;
	string init_mod2_description;
	string init_mod2_icon;
	string init_mod2_pic;

	property Mod1AmmoUse    : init_mod1_ammoUse;
	property Mod1Cooldown   : init_mod1_cooldown, init_mod1_cooldown_over;
	property Mod1Charge     : init_mod1_charge, init_mod1_charge_over;
	property Mod1Tag        : init_mod1_tag;
	property Mod1Description: init_mod1_description;
	property Mod1Icon       : init_mod1_icon;
	property Mod1Pic        : init_mod1_pic;

	property Mod2AmmoUse    : init_mod2_ammoUse;
	property Mod2Cooldown   : init_mod2_cooldown, init_mod2_cooldown_over;
	property Mod2Charge     : init_mod2_charge, init_mod2_charge_over;
	property Mod2Tag        : init_mod2_tag;
	property Mod2Description: init_mod2_description;
	property Mod2Icon       : init_mod2_icon;
	property Mod2Pic        : init_mod2_pic;

	/*
	 * Actor States n' Defaults
	 */
	Default
	{
		ArgModWeapon.Mod1AmmoUse 1;
		ArgModWeapon.Mod1Cooldown 0, 0;
		ArgModWeapon.Mod1Charge 0, 0;
		ArgModWeapon.Mod1Tag "Mod 1";
		ArgModWeapon.Mod1Description "THIS SURE IS A MOD";
		ArgModWeapon.Mod1Icon "";
		ArgModWeapon.Mod1Pic "";

		ArgModWeapon.Mod2AmmoUse 1;
		ArgModWeapon.Mod2Cooldown 0, 0;
		ArgModWeapon.Mod2Charge 0, 0;
		ArgModWeapon.Mod2Tag "Mod 1";
		ArgModWeapon.Mod2Description "THIS SURE IS A MOD";
		ArgModWeapon.Mod2Icon "";
		ArgModWeapon.Mod2Pic "";

		+WEAPON.NOALERT
		+WEAPON.AMMO_OPTIONAL
		+WEAPON.ALT_AMMO_OPTIONAL
	}
	States
	{
	
	/* Ready Mod-Jump */
	
	Ready:
		"####" "#" 0 {
			A_ClearReFire();
			return Arg_A_JumpMod("Mod1Ready", "Mod2Ready", "Mod0Ready");
		}
	Mod0Ready:
	Mod1Ready:
	Mod2Ready:
	ReadyLoop:
		"####" "#" 1 A_WeaponReady(WRF_ALLOWRELOAD);
		Loop;
		
	/* Select Mod-Jump */
	
	Select:
		"####" "#" 0 Arg_A_JumpMod("Mod1Select", "Mod2Select", "Mod0Select");
	Mod0Select:
	Mod1Select:
	Mod2Select:
		Goto SelectLoop;
		
	/* Fire Mod-Jump -- need to make sure we're not holding down altfire. */
	
	Fire:
		"####" "#" 0 {
			if(Arg_A_InstallMod(1)) {
				return ResolveState("ModSwapDown");
			} else if(!Arg_SynthAltFire() && Arg_A_CheckAmmo()) {
				return ResolveState("Mod0Fire");
			} else {
				return ResolveState("DontFire");
			}
		}
		Goto DontFire;
	Mod0Fire:
		"####" "#" 1;
		Goto Ready;
		
	/* Deselect doesn't need a mod jump since it's just "####" anyway. */
	
	Deselect:
		"####" "#" 0 {
			A_ZoomFactor(1.0);
			A_SetCrosshair(0);
		}
		Goto DeselectLoop;
		
	/* Mod Swapping. Uses the Reload bind for convenience. */
	
	Reload:
		// call the swap function and start the animation if successful
		"####" "#" 0 Arg_A_SwapMod();
	ModSwapDown:
		// lower the weapon and jump to the raise animation
		"####" "########" 1 A_WeaponOffset(0.0, 12.0, WOF_KEEPX | WOF_ADD);
		"####" "#" 0 {
			Arg_A_ClearModCooldown();
			return Arg_A_JumpMod("Mod1Raise", "Mod2Raise");
		}
	Mod1Raise:
	Mod2Raise:
	ModSwapUp:
		// raise the weapon & start the swap animation
		"####" "########" 1 A_WeaponOffset(0.0,-12.0, WOF_KEEPX | WOF_ADD);
		"####" "#" 0 Arg_A_JumpMod("Mod1Swap", "Mod2Swap");
	Mod1Swap:
	Mod2Swap:
	DontSwap:
		"####" "#" 1 A_WeaponReady;
		Goto Ready;
		
	/* Mod Firing. Maximum Dangertime. */
	
	AltFire:
		"####" "#" 0 {
			if(Arg_A_InstallMod(2)) {
				return ResolveState("ModSwapDown");
			} else if(Arg_A_CheckAmmo()) {
				return Arg_A_JumpMod("Mod1UpCheck", "Mod2UpCheck", "DontFire", true);
			} else {
				return ResolveState("DontFire");
			}
		}
	AltHold:
		"####" "#" 0 Arg_A_JumpMod("Mod1Hold", "Mod2Hold");
		Goto DontFire;
	ModDown:
		"####" "#" 0 Arg_A_JumpMod("Mod1Down", "Mod2Down");
		Goto DontFire;
	/* [TODO] remove these band-aids after ACS is ousted. */
	Mod1UpCheck:
		"####" "#" 0 Arg_A_JumpIfNoAmmo('Ready', invoker.mod[1].ammoUse);
		"####" "#" 0 ResolveState("Mod1Up");
	Mod2UpCheck:
		"####" "#" 0 Arg_A_JumpIfNoAmmo('Ready', invoker.mod[2].ammoUse);
		"####" "#" 0 ResolveState("Mod2Up");
	/* [/TODO] */
	Mod1Up:
	Mod2Up:
	Mod1Hold:
	Mod2Hold:
	Mod1Down:
	Mod2Down:
	DontFire:
		"####" "#" 1 A_WeaponReady(WRF_NOFIRE);
		Goto Ready;
	Cooldown:
		"####" "#" 0 {
			A_ClearReFire();
			Arg_A_StartModCooldown();
		}
		Goto Ready;
	}
	
	/*
	 * Overridden BeginPlay function, for special shit.
	 */
	override void BeginPlay()
	{
		Super.BeginPlay();
		mod[0] = new('ArgMod'); // [TODO] remove this awful placeholder :P
		mod[1] = new('ArgMod');
		mod[2] = new('ArgMod');
		
		// Initialize mods from properties
		mod[1].ammoUse        = init_mod1_ammoUse;
		mod[1].cooldown.init(0, init_mod1_cooldown, max(init_mod1_cooldown_over, init_mod1_cooldown));
		mod[1].charge.init  (0, init_mod1_charge  , max(init_mod1_charge_over  , init_mod1_charge  ));
		mod[1].tag            = StringTable.Localize(init_mod1_tag);
		mod[1].description    = StringTable.Localize(init_mod1_description);
		mod[1].icon           = StringTable.Localize(init_mod1_icon);
		mod[1].pic            = StringTable.Localize(init_mod1_pic);

		mod[2].ammoUse        = init_mod2_ammoUse;
		mod[2].cooldown.init(0, init_mod2_cooldown, max(init_mod2_cooldown_over, init_mod2_cooldown));
		mod[2].charge.init  (0, init_mod2_charge  , max(init_mod2_charge_over  , init_mod2_charge  ));
		mod[2].tag            = StringTable.Localize(init_mod2_tag);
		mod[2].description    = StringTable.Localize(init_mod2_description);
		mod[2].icon           = StringTable.Localize(init_mod2_icon);
		mod[2].pic            = StringTable.Localize(init_mod2_pic);
		
		// Set MinSelAmmo1 to 1 for all mod weapons to thwart +AMMO_OPTIONAL;
		// this is a special value that tells BestWeapon (the "switch to
		// highest-priority weapon when running out of ammo" function) to
		// ENSURE that you have at least 1 unit of ammo before picking it.
		// It is NOT checked when selecting the weapon manually, which is
		// precisely what we want since weapons need to be selectable to mod them.
		
		// Oddly, this value isn't exposed via a property, so we've got to
		// set it in a function. Welpo.
		let this = ArgModWeapon(self);
		this.MinSelAmmo1 = 1;
	}
	
	/*
	 * Overridden Tick function, for extra-special shit.
	 */
	override void Tick()
	{
		Super.Tick();
		
		// Subtract 1 from mod cooldown every tick, no matter
		// what else happens. Huzzah!
		let this = ArgModWeapon(self);
		this.mod[1].cooldown.dec();
		this.mod[2].cooldown.dec();
	}
	
	/*
	 * Jump to one of two states depending on which mod is selected.
	 * If no mods are selected, no state jump occurs.
	 */
	action state Arg_A_JumpMod(statelabel mod1label, statelabel mod2label, statelabel mod0label = null, bool checkCooldown = false) {
		// Jump to either the mod 1 or mod 2 state depending on which exists.
		// Optionally, check if cooldown is complete first.
		if(invoker.modSelected == 1 && (!checkCooldown || invoker.mod[1].cooldown.get() == 0)) {
			return ResolveState(mod1label);

		} else if(invoker.modSelected == 2 && (!checkCooldown || invoker.mod[2].cooldown.get() == 0)) {
			return ResolveState(mod2label);

		} else {
			return ResolveState(mod0label);
		}
	}
	
	/*
	 * Attempt to install the specified mod. If already installed (or the
	 * shop menu isn't opened), 'false' is returned; else 'true'.
	 */
	action bool Arg_A_InstallMod(int modToInstall) {

		let modkit = ArgModKit(self.FindInventory("ArgModKit"));
		if(modkit) {
			bool consumeKit, doJump;
			[consumeKit, doJump] = modkit.Arg_A_ApplyModKit(modToInstall, invoker);
			if(consumeKit) {
				// consume the mod kit and play some fun soundage.
				// [TODO] screen flash effect here.
				A_TakeInventory("ArgModKit", 1);
				A_PlaySound("items/modkit/apply", CHAN_AUTO);
			}
			return doJump;
		} else {
			// don't do a thing otherwise. continue firing, gents!
			return false;
		}
	}

	/*
	 * Swap the currently-selected mod. 'Nuff said.
	 */
	action state Arg_A_SwapMod() {
	
		// first, cycle through the mod kit if we're in the menu.
		let modkit = ArgModKit(self.FindInventory("ArgModKit"));
		if(modkit && modkit.active) {
			if(!Arg_OldButtons(BT_RELOAD) && modkit.Arg_A_CycleModKit()) {
				// [TODO] play cycle sound.
			}
			return ResolveState("DontSwap");

		} else {
			// Do a mod swap.
			// determine what to swap to. Hooray goofy extra logic for zero.
			int modToSelect = 0;
			if(invoker.modSelected == 1 && invoker.mod[2].enabled) {
				modToSelect = 2;
			} else if(invoker.modSelected == 2 && invoker.mod[1].enabled) {
				modToSelect = 1;
			} else if(invoker.modSelected == 0) {
				if(invoker.mod[1].enabled) {
					modToSelect = 1;
				} else if(invoker.mod[2].enabled) {
					modToSelect = 2;
				}
			}

			// if we've successfully done a swap, initiate the animation.
			if(modToSelect > 0) {
				invoker.modSelected = modToSelect;
				return ResolveState("ModSwapDown");
			} else {
				return ResolveState("DontSwap");
			}
		}
	}
	
	/*
	 * Start the cooldown cycle for the selected mod.
	 */
	action void Arg_A_StartModCooldown() {
		if(invoker.modSelected > 0 && invoker.modSelected <= 2) {
			invoker.mod[invoker.modSelected].cooldown.toMax();
		}
	}
	
	/*
	 * Clear the cooldown cycle for the selected mod.
	 * Generally done on weapon swap.
	 */
	action void Arg_A_ClearModCooldown() {
		if(invoker.modSelected > 0 && invoker.modSelected <= 2) {
			invoker.mod[invoker.modSelected].cooldown.toMin();
		}
	}
}
